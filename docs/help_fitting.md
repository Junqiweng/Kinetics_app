# 拟合与数值设置（让拟合更稳、更快）

## 1) 目标函数（拟合在最小化什么？）

App 使用非线性最小二乘（`scipy.optimize.least_squares`）最小化：

$$\Phi(\theta)=\frac{1}{2}\sum_{i=1}^{N} r_i(\theta)^2$$

其中 $\theta$ 是你勾选了 `Fit_*` 的参数集合。

## 2) 残差类型（你在最小化什么“误差”）

在「③ 拟合与结果」可选择残差类型：

- **绝对残差**：$$r=y^{pred}-y^{meas}$$
- **相对残差**：$$r=\frac{y^{pred}-y^{meas}}{y^{meas}}$$
- **百分比残差（带偏置）**：$$r=\frac{y^{pred}-y^{meas}}{|y^{meas}|+\\varepsilon}$$

说明：当测量值很小（接近 0）时，相对/百分比残差更容易“炸”；此时优先用绝对残差，或检查单位/数据质量。

## 3) 新手推荐：分阶段拟合（比“一口气全放开”稳很多）

1) **先只拟合 $k_0$**（固定 $E_a$ 与级数 $n$）→ 让模型先能跟上数量级  
2) 再放开 $E_a$（需要足够温度跨度，否则 $E_a$ 往往不可辨识）  
3) 最后再放开级数 $n$（参数相关性通常更强）  

对于更复杂模型：

- **L-H**：先把幂律部分跑稳，再逐步放开 $K_0$、$E_{a,K}$、$m$  
- **可逆**：建议先只拟合正向参数，再放开逆向参数

## 4) ODE 求解器与容差（影响“能不能算出来”）

- 非刚性/简单问题：`RK45`
- 刚性/收敛困难：`BDF` 或 `Radau`

当你遇到 `solve_ivp 失败`、或“参数一改就崩”，按顺序尝试：

1) 求解器换 `BDF`（最常用的稳健选项）  
2) 放宽容差：把 `rtol/atol` 调大一档（例如 `1e-6 → 1e-5`）  
3) 缩紧参数边界、改进初值（避免极端速率常数）  

## 5) `diff_step (Finite Diff)`（数值差分步长，影响 Jacobian）

Jacobian 通过数值差分得到；`diff_step` 太小会更“敏感”，在噪声/非光滑情况下可能导致：

- 拟合抖动
- 看起来“不动”

建议从 `1e-2 ~ 1e-3`（相对步长）试起；稳定后再逐步调小。

## 6) `max_step_fraction (ODE)`（限制积分步长）

用于限制 `solve_ivp(max_step)`：

- 设为 `0`：不限制（solve_ivp 默认）
- 反应很快、曲线很陡时：适当减小可能更稳（但通常更慢）

## 7) Multi-start（多起点）

当你拟合参数多、或容易卡在局部最小值时：

- 勾选 `Multi-start (多起点)`
- `Start Points` 建议 `5~20`

它会更慢，但通常更稳。

## 8) 性能提示（为什么会慢？）

每一次目标函数评估，都会对 CSV 的每一行工况进行模型计算（PFR/BSTR 用 `solve_ivp`；CSTR 还要做稳态求解）。

如果数据很多（例如上百行以上）且参数很多：

- 先用少量数据/少量拟合参数把流程跑通
- 关闭“自动刷新”减少卡顿
